# 심화된 자료구조

### 연결리스트(Linked List)

**연결 리스트란?**

-   여러개의 **노드**들이 한 줄로 연결

-   노드 = **저장할 데이터** + 다음 노드로의 연결



**단순 연결 리스트**

-   **한 방향**으로만 이어진 연결 리스트



**이중 연결 리스트**

-   **양쪽 방향**으로 이어진 연결 리스트



**원형 연결 리스트**

-   **가장 뒤의 노드**가 **맨 앞의 노드**에 연결된 연결 리스트



**기타 연결 리스트**

-   **아무 형태**의 연결 리스트 모두 가능!



**배열 VS 연결 리스트**

-   **배열**: 인덱스 이용해서 데이터 접근

-   **연결 리스트**: 현재 노드에서 연결된 노드로만



**헤드 Head**

-   어딘가에서는 시작을 해야하므로!



**연결 리스트 시간 복잡도**

-   자료 중간에 추가/삭제 : `O(1)`



배열 시간 복잡도와 비교해보면?

nums.insert(3, 9) : `O(N)`



[실습 1]

**연결 리스트 ↔ 배열 반환하기**

연결 리스트 클래스 LinkedList와, 그 노드 클래스 Node가 주어졌습니다.

연결 리스트 객체가 주어졌을때 이를 배열로 변환해서 반환하는 함수 toArray와, 배열이 주어졌을때 이를 연결 리스트로 변환해서 반환하는 함수 toLinkedList를 구현 해 봅시다.



[실습 2]

연결 리스트에서 노드 삭제



### 큐(Queue)

**큐**

-   먼저 줄 선 사람이 먼저 나간다
    = FIRST IN FIRST OUT (FIFO)



**큐 시간 복잡도**

-   입력하기 : `O(1)`
-   출력하기 : `O(1)`



**큐 작동 방식**



**큐 in Python**

-   queue library 활용

```python
import queue
q = queue.Queue()
q.put(2)
q.put(8)
q.get()
```



-   배열을 큐(Queue)로 활용

```python
q = [8, 19, 37, 4, 5]

q.insert(0, 2) # 맨 앞에 입력한다
q.pop() # 맨 뒤에서 가져온다
```

배열을 활용했을 때 문제점은? 시간 복잡도!



[실습 3]

스트리밍 데이터의 이동 평균



### 스택(Stack)

**스택**

-   나중에 줄 선 사람이 먼저 나간다

    = LAST IN FIRST OUT (LIFO)



**스택 시간 복잡도**

-   입력하기 : `O(1)`
-   출력하기 : `O(1)`



**스택 작동 방식**



**스택 in Python**

-   배열을 스택(Stack)으로 활용

```python
Stack = []
Stack.append(2)
Stack.append(5)
Stack.pop() #5를 반환
```



[실습 4]

괄호 매칭

